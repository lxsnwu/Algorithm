
## 只出现一次的数字
leetcode136
```
示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4
```
解题思路：
可能一开始会想到使用hashmap，但是如何不使用额外空间来实现呢？

首先我们需要知道：
1.交换律：a ^ b ^ c <=> a ^ c ^ b
2.任何数于0异或为任何数 0 ^ n => n
3.相同的数异或为0: n ^ n => 0

```
int singleNumber(vector<int>& nums) {
       int len = nums.size();
        int result=0;
       for(int i=0;i<len;i++){
           result ^=nums[i];
       } 
        return result;
 }
```
## 位1的个数
leetcode191

```
示例 1：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 2：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```
思路一：将n和1与（&）运算，然后再右移；其中，如果运算结果是1则表明n的最后一位是1，count+1；否则就是最后一位是0，count不变.
缺陷：这种没有考虑到n是负数的时候。在计算机中负数存储成补码，右移的时候补位是1而不是0，所以1会一直存在，这样会造成一直循环，导致陷入死循环。

思路二：将n和1与（&）运算，可以n不动，让1左移，其中，如果运算结果是1则表明n的最后一位是1，count+1；否则就是最后一位是0，count不变.
```
public int numberOf1(int n){
  int count = 0;
  int flag = 1;
  while(flag!=0){
    if((n&flag)!=0){
      count++;
    }
    flag = flag<<1;
  }
return count;
}
```

思路三：一个整数减去1，相当于把这个数最右边的1的后边的变成0,0变成1；1的前边的0,1不变。举例说明：1100，减去1，变成1011。将这两个数做与&运算，1100&1011会得到1000，可以看出把1100最右边的1变成了0，所以我们可以用n&（n-1）来计算有多少个1；n能运行多少次这样的操作，就有多少个1.
```
public int NumberOf1(int n) {
        int count=0;
		while(n!=0){
            ++count;
            n=n&(n-1);
        }
        return count;
    }
```



















